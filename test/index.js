'use strict'

const plugin = require('../')
const expect = require('expect')
const path   = require('path')
const fs     = require('fs')

function concat (name, subdir) {
  let file = path.join(__dirname, subdir || 'expected', name)

  file = file.replace(/\\/g, '/')
  if (!path.extname(file)) file += '.js'
  return file
}

process.chdir(__dirname)

function testStr (code, expected, opts) {
  let result = plugin(opts).transform(code, 'test.js')
  expect(result.code).toBe(expected)
}

describe('rollup-plugin-cleanup', () => {

  const emptyLines10 = '\n\n\n\n\n\n\n\n\n\n'
  const emptyLinesTop = emptyLines10 + 'X'
  const emptyLinesBottom = 'X' + emptyLines10
  const emptyLinesMiddle = emptyLines10 + 'X' + emptyLines10 + 'X' + emptyLines10

  it('by default removes all the empty lines and normalize to unix', () => {
    testStr([
      '',
      'abc ',
      'x\t',
      '\r\ny \r',
      '\n\n\r\t',
      'z '
    ].join('\n'), 'abc\nx\ny\nz')
  })

  it('do not touch current indentation of non-empty lines', () => {
    testStr('  \n X\n  X ', ' X\n  X')
  })

  it('has fine support for empty lines with `maxEmptyLines`', () => {
    testStr(emptyLinesTop, 'X')
    testStr(emptyLinesBottom, 'X\n')

    testStr(emptyLinesTop, '\nX', { maxEmptyLines: 1 })
    testStr(emptyLinesBottom, 'X\n\n', { maxEmptyLines: 1 })
    testStr(emptyLinesMiddle, '\nX\n\nX\n\n', { maxEmptyLines: 1 })

    testStr(emptyLinesTop, '\n\n\nX', { maxEmptyLines: 3 })
    testStr(emptyLinesBottom, 'X\n\n\n\n', { maxEmptyLines: 3 })
    testStr(emptyLinesMiddle, '\n\n\nX\n\n\n\nX\n\n\n\n', { maxEmptyLines: 3 })
  })

  it('can leave all the lines setting `maxEmptyLines` = -1', () => {
    testStr(emptyLinesTop, emptyLinesTop, { maxEmptyLines: -1 })
    testStr(emptyLinesBottom, emptyLinesBottom, { maxEmptyLines: -1 })
    testStr(emptyLinesMiddle, emptyLinesMiddle, { maxEmptyLines: -1 })
  })

  it('have convertion to Windows line-endings with `eolType` = "win"', () => {
    const opts = { maxEmptyLines: 1, eolType: 'win' }
    testStr(emptyLinesTop, '\r\nX', opts)
    testStr(emptyLinesBottom, 'X\r\n\r\n', opts)
    testStr(emptyLinesMiddle, '\r\nX\r\n\r\nX\r\n\r\n', opts)
  })

  it('and convertion to Mac line-endings with `eolType` = "mac"', () => {
    const opts = { maxEmptyLines: 1, eolType: 'mac' }
    testStr(emptyLinesTop, '\rX', opts)
    testStr(emptyLinesBottom, 'X\r\r', opts)
    testStr(emptyLinesMiddle, '\rX\r\rX\r\r', opts)
  })

  it('makes normalization to the desired `eolType` lines', () => {
    const opts = { maxEmptyLines: -1, eolType: 'mac' }
    testStr('\r\n \n\r \r\r\n \r\r \n', '\r\r\r\r\r\r\r\r', opts)
  })})

describe('SourceMap support', () => {

  let rollup = require('rollup').rollup

  it('test bundle generated by rollup w/inlined sourcemap', () => {
    return rollup({
      entry: concat('bundle-src.js', 'maps'),
      sourceMap: true,
      plugins: [
        plugin()
      ]
    }).then(function (bundle) {
      let result = bundle.generate({
        format: 'iife',
        indent: true,
        moduleName: 'myapp',
        sourceMap: 'inline',
        sourceMapFile: 'maps/bundle.js', // generates sorce filename w/o path
        banner: '/*\n plugin version 1.0\n*/',
        footer: '/* follow me on Twitter! @amarcruz */'
      })
      let code = result.code + '\n//# source' + 'MappingURL=' + result.map.toUrl()

      /*
        If you modified the source in maps/bundle-src.js, you
        need to write the bundle and test it in the browser again.
      */
      //console.log('\t--- writing bundle with inlined sourceMap...')
      //fs.writeFileSync(concat('bundle', 'maps'), code, 'utf8')

      let expected = fs.readFileSync(concat('bundle', 'maps'), 'utf8')
      expect(code).toBe(expected, 'Genereted code is incorrect!')
    })
  })
})
